"""
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üåü –¶–∏—Ç–∞—Ç—É–º ‚Äî Telegram –±–æ—Ç –≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏—è
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìù –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ:
    Telegram-–±–æ—Ç –¥–ª—è –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã—Ö, –º—É–¥—Ä—ã—Ö –∏ –∫—Ä–∞—Å–∏–≤—ã—Ö —Ü–∏—Ç–∞—Ç

üí° –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
    ‚Ä¢ –¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–¥–±–æ—Ä–∫–∏: üí™ –ú–æ—Ç–∏–≤–∞—Ü–∏—è, ‚ù§Ô∏è –õ—é–±–æ–≤—å, üß† –ú—É–¥—Ä–æ—Å—Ç—å, üå± –ñ–∏–∑–Ω—å
    ‚Ä¢ –í—ã–±–æ—Ä –ª—é–±–∏–º—ã—Ö —Ç–µ–º
    ‚Ä¢ –ö—Ä–∞—Å–∏–≤–æ–µ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ —Å –∞–≤—Ç–æ—Ä–∞–º–∏
    ‚Ä¢ –ì–∏–±–∫–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏: –∫–∞–∂–¥—ã–π —á–∞—Å, –µ–∂–µ–¥–Ω–µ–≤–Ω–æ, –≤ —Å–≤–æ—ë –≤—Ä–µ–º—è
    ‚Ä¢ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∞–º–∏
    ‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ —á–µ—Ä–µ–∑ /timezone

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
–ê–≤—Ç–æ—Ä: @artemtit
GitHub: github.com/artemtit/quote_bot
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"""

import os
import re
import logging
import json
import signal
import sys
import asyncio
import time as time_module
from datetime import time as dt_time, timedelta, timezone
import datetime
from collections import defaultdict
import pytz
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    Application, CommandHandler, MessageHandler, ContextTypes, filters, CallbackQueryHandler
)
from telegram.helpers import escape_markdown as tg_escape
from dotenv import load_dotenv

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
load_dotenv()
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    raise ValueError("–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω–∞! –£–∫–∞–∂–∏ –µ—ë –≤ —Ñ–∞–π–ª–µ .env")

MOSCOW_TZ = 'Europe/Moscow'
STATE_FILE = "bot_state.json"

# –¢–µ–º—ã –∏ –∏—Ö —ç–º–æ–¥–∑–∏
THEMES = {
    "motivation": "üí™ –ú–æ—Ç–∏–≤–∞—Ü–∏—è",
    "love": "‚ù§Ô∏è –õ—é–±–æ–≤—å",
    "wisdom": "üß† –ú—É–¥—Ä–æ—Å—Ç—å",
    "life": "üå± –ñ–∏–∑–Ω—å"
}

# English labels for themes
THEMES_EN = {
    "motivation": "üí™ Motivation",
    "love": "‚ù§Ô∏è Love",
    "wisdom": "üß† Wisdom",
    "life": "üå± Life"
}

# UTC —Å–º–µ—â–µ–Ω–∏—è –¥–ª—è —á–∞—Å–æ–≤—ã—Ö –ø–æ—è—Å–æ–≤
UTC_OFFSETS = {
    "UTC-12": "UTC-12:00",
    "UTC-11": "UTC-11:00",
    "UTC-10": "UTC-10:00",
    "UTC-9": "UTC-9:00",
    "UTC-8": "UTC-8:00",
    "UTC-7": "UTC-7:00",
    "UTC-6": "UTC-6:00",
    "UTC-5": "UTC-5:00",
    "UTC-4": "UTC-4:00",
    "UTC-3": "UTC-3:00",
    "UTC-2": "UTC-2:00",
    "UTC-1": "UTC-1:00",
    "UTC+0": "UTC+0:00 (–ì—Ä–∏–Ω–≤–∏—á)",
    "UTC+1": "UTC+1:00",
    "UTC+2": "UTC+2:00",
    "UTC+3": "UTC+3:00 (–ú–æ—Å–∫–≤–∞)",
    "UTC+4": "UTC+4:00",
    "UTC+5": "UTC+5:00",
    "UTC+6": "UTC+6:00",
    "UTC+7": "UTC+7:00",
    "UTC+8": "UTC+8:00",
    "UTC+9": "UTC+9:00",
    "UTC+10": "UTC+10:00",
    "UTC+11": "UTC+11:00",
    "UTC+12": "UTC+12:00",
    "UTC+13": "UTC+13:00",
}

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
ALL_QUOTES = {}
USER_MESSAGE_TIMES = defaultdict(list)
USER_LOCKS = defaultdict(lambda: asyncio.Lock())

# –Ø–∑—ã–∫–∏
LANGUAGES = {
    'ru': '–†—É—Å—Å–∫–∏–π',
    'en': 'English'
}

# –õ–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä –∫–ª—é—á–µ–π)
MESSAGES = {
    'ru': {
        'start_full': (
            "–ü—Ä–∏–≤–µ—Ç! üåü –Ø ‚Äî –±–æ—Ç –≤–¥–æ—Ö–Ω–æ–≤–ª—è—é—â–∏—Ö —Ü–∏—Ç–∞—Ç!\n\n"
            "–¢—ã –º–æ–∂–µ—à—å –ø–æ–ª—É—á–∞—Ç—å –º–æ—Ç–∏–≤–∞—Ü–∏—é, –º—É–¥—Ä–æ—Å—Ç—å, –ª—é–±–æ–≤—å –∏ –∂–∏–∑–Ω–µ–Ω–Ω—ã–µ —Å–æ–≤–µ—Ç—ã –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.\n\n"
            "‚Ä¢ –í—ã–±–∏—Ä–∞–π —Ç–µ–º—ã ‚Äî –∫–Ω–æ–ø–∫–∞ \"üìö –í—ã–±—Ä–∞—Ç—å —Ç–µ–º—ã\"\n"
            "‚Ä¢ –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–π —Ä–∞—Å—Å—ã–ª–∫–∏: –µ–∂–µ–¥–Ω–µ–≤–Ω–æ, –∫–∞–∂–¥—ã–π —á–∞—Å –∏–ª–∏ –≤ —Å–≤–æ—ë –≤—Ä–µ–º—è\n"
            "‚Ä¢ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ ‚Äî –∫–æ–º–∞–Ω–¥–∞ /stats\n\n"
            "–ï—Å–ª–∏ —Ö–æ—á–µ—à—å –∏–∑–º–µ–Ω–∏—Ç—å —è–∑—ã–∫, –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /language\n"
            "–ï—Å–ª–∏ –Ω—É–∂–Ω–æ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Ä–µ–º—è —Ä–∞—Å—Å—ã–ª–æ–∫, –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /timezone"
        ),
        'choose_language': "–í—ã–±–µ—Ä–∏ —è–∑—ã–∫ / Choose your language:",
        'timezone_note': "–ï—Å–ª–∏ —Ç–µ–±–µ –Ω—É–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å –¥–ª—è —Ä–∞—Å—Å—ã–ª–æ–∫, –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /timezone –∏ –≤—ã–±–µ—Ä–∏ —Å–≤–æ–π UTC!",
        'awaiting_time_expired': "‚è≥ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –≤–≤–æ–¥–∞ –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É.",
        'invalid_time_format': "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: 14:00",
        'hourly_already': "‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–ö–∞–∂–¥—ã–π —á–∞—Å¬ª —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞.",
        'spam': "‚è≥ –ù–µ —Å–ø–∞–º–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞.",
        'unknown_command': "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.",
        'btn_get_quote': "‚ú® –ü–æ–ª—É—á–∏—Ç—å —Ü–∏—Ç–∞—Ç—É",
        'btn_choose_topics': "üìö –í—ã–±—Ä–∞—Ç—å —Ç–µ–º—ã",
        'btn_daily_7': "‚è∞ –ï–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 7:00",
        'btn_choose_time': "üïí –í—ã–±—Ä–∞—Ç—å —Å–≤–æ—ë –≤—Ä–µ–º—è",
        'btn_hourly': "üìÖ –ö–∞–∂–¥—ã–π —á–∞—Å",
        'btn_manage_jobs': "üõë –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∞–º–∏",
        'btn_stats': "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞",
        'btn_create_delivery': "‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Ä–∞—Å—Å—ã–ª–∫—É",
        'btn_more_quote': "üîÑ –ï—â—ë —Ü–∏—Ç–∞—Ç—É",
        'btn_topics_done': "‚úîÔ∏è –ì–æ—Ç–æ–≤–æ",
        'prompt_custom_time': "–ù–∞–ø–∏—à–∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú.\n–ü—Ä–∏–º–µ—Ä: 14:30",
        'prompt_hourly_time': "–£–∫–∞–∂–∏ –≤—Ä–µ–º—è, —Å –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω–∞—á–∏–Ω–∞—Ç—å —Ä–∞—Å—Å—ã–ª–∫—É –∫–∞–∂–¥—ã–π —á–∞—Å (—Ñ–æ—Ä–º–∞—Ç –ß–ß:–ú–ú).\n–ü—Ä–∏–º–µ—Ä: 13:00",
        'create_delivery_title': "–°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏",
        'choose_frequency': "–í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Å—Ç–æ—Ç—É –æ—Ç–ø—Ä–∞–≤–∫–∏:",
        'freq_hourly': "üìÖ –ö–∞–∂–¥—ã–π —á–∞—Å",
        'freq_daily': "‚è∞ –ï–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 7:00",
        'freq_once': "üïí –û–¥–∏–Ω —Ä–∞–∑",
        'enter_start_time_freq': "–£–∫–∞–∂–∏ –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ —Ä–∞—Å—Å—ã–ª–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú.\n–ü—Ä–∏–º–µ—Ä: 13:00",
        'confirm_create_delivery': "‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞: {freq} ‚Äî {time}",
        'creation_cancelled': "‚ùå –°–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.",
        'no_active_jobs': "–£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—Å—ã–ª–æ–∫.",
        'choose_job_to_disable': "–í—ã–±–µ—Ä–∏ —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è:",
        'removed_jobs': "‚èπ –û—Ç–∫–ª—é—á–µ–Ω–æ {n} —Ä–∞—Å—Å—ã–ª–∫–∏.",
        'job_disabled': "‚èπ –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞.",
        'job_already_disabled': "–†–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –æ—Ç–∫–ª—é—á–µ–Ω–∞.",
            'hourly_enabled_first': "‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–ö–∞–∂–¥—ã–π —á–∞—Å¬ª –≤–∫–ª—é—á–µ–Ω–∞! –ü–µ—Ä–≤–∞—è —Ü–∏—Ç–∞—Ç–∞ –ø—Ä–∏–¥—ë—Ç –≤ {time} , –¥–∞–ª–µ–µ ‚Äî –∫–∞–∂–¥—ã–π —á–∞—Å.",
            'daily_enabled': "‚úÖ –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –≤ {time} –≤–∫–ª—é—á–µ–Ω–∞ .",
            'timezone_changed': "‚úÖ –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å –∏–∑–º–µ–Ω—ë–Ω –Ω–∞: {tz}",
            'invalid_timezone': "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å: {tz}\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –Ω–∞–ø–∏—Å–∞–Ω–∏—è. –ü—Ä–∏–º–µ—Ä—ã:\n‚Ä¢ Europe/Moscow\n‚Ä¢ America/New_York\n‚Ä¢ Asia/Tokyo",
            'timezone_already': "‚ÑπÔ∏è –≠—Ç–æ—Ç —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω:\n{tz}\n\n–í—ã–±–µ—Ä–∏ –¥—Ä—É–≥–æ–π –ø–æ—è—Å –∏–ª–∏ –Ω–∞–∂–º–∏ /start –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é.",
            'language_set': "‚úÖ –Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {lang}",
            'custom_already_active': "‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–í {time}¬ª —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞.",
            'custom_enabled': "‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–í {time}¬ª –≤–∫–ª—é—á–µ–Ω–∞.",
            'invalid_time_range': "‚ùå –í—Ä–µ–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 00:00 –¥–æ 23:59.",
        'topics_saved': "‚úÖ –¢–µ–º—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã! –¢–µ–ø–µ—Ä—å —Ç—ã –±—É–¥–µ—à—å –ø–æ–ª—É—á–∞—Ç—å —Ü–∏—Ç–∞—Ç—ã —Ç–æ–ª—å–∫–æ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º —Ç–µ–º–∞–º.",
        'btn_remove_all': "–û—Ç–º–µ–Ω–∏—Ç—å –≤—Å—ë",
        'label_at_time': "–í {time}",
        'choose_topics_prompt': "‚úÖ –í—ã–±–µ—Ä–∏ —Ç–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ç–µ–±–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã.\n–ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ:",
        'quotes_not_loaded': "–¶–∏—Ç–∞—Ç—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.",
        'no_quotes_in_topics': "–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ü–∏—Ç–∞—Ç –≤ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ç–µ–º–∞—Ö. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–∏–µ —Ç–µ–º—ã.",
        'stats_received': "üìä –¢—ã –ø–æ–ª—É—á–∏–ª(–∞) {n} —Ü–∏—Ç–∞—Ç!",
    },
    'en': {
        'start_full': (
            "Hi! üåü I'm a quotes inspiration bot!\n\n"
            "You can receive motivation, wisdom, love and life quotes every day.\n\n"
            "‚Ä¢ Choose topics ‚Äî button \"üìö Choose topics\"\n"
            "‚Ä¢ Configure deliveries: daily, hourly or at your time\n"
            "‚Ä¢ Stats ‚Äî command /stats\n\n"
            "To change language, use /language\n"
            "To adjust deliveries time, use /timezone"
        ),
        'choose_language': "Choose your language / –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:",
        'timezone_note': "To change timezone for deliveries, use /timezone and pick your UTC!",
        'awaiting_time_expired': "‚è≥ Time to input expired. Please repeat the command.",
        'invalid_time_format': "‚ùå Invalid format. Example: 14:00",
        'hourly_already': "‚úÖ Hourly delivery is already active.",
        'spam': "‚è≥ Please don't spam.",
        'unknown_command': "Unknown command.",
        'btn_get_quote': "‚ú® Get quote",
        'btn_choose_topics': "üìö Choose topics",
        'btn_daily_7': "‚è∞ Daily at 7:00",
        'btn_choose_time': "üïí Choose your time",
        'btn_hourly': "üìÖ Every hour",
        'btn_manage_jobs': "üõë Manage deliveries",
        'btn_stats': "üìä Statistics",
        'btn_create_delivery': "‚ûï Create new delivery",
        'btn_more_quote': "üîÑ More quote",
        'btn_topics_done': "‚úîÔ∏è Done",
        'prompt_custom_time': "Send time in HH:MM format (your timezone).\nExample: 14:30",
        'prompt_hourly_time': "Specify start time to begin hourly delivery (HH:MM).\nExample: 13:00",
        'create_delivery_title': "Create delivery",
        'choose_frequency': "Choose frequency:",
        'freq_hourly': "üìÖ Every hour",
        'freq_daily': "‚è∞ Daily at 7:00",
        'freq_once': "üïí Once",
        'enter_start_time_freq': "Enter start time in HH:MM format (your timezone).\nExample: 13:00",
        'confirm_create_delivery': "‚úÖ Delivery created: {freq} ‚Äî {time}",
        'creation_cancelled': "‚ùå Delivery creation cancelled.",
        'no_active_jobs': "You have no active deliveries.",
        'choose_job_to_disable': "Choose delivery to disable:",
        'removed_jobs': "‚èπ Disabled {n} deliveries.",
        'job_disabled': "‚èπ Delivery disabled.",
        'job_already_disabled': "Delivery already disabled.",
            'hourly_enabled_first': "‚úÖ Hourly delivery enabled! First quote will arrive at {time} (your timezone), then every hour.",
            'daily_enabled': "‚úÖ Daily delivery at {time} enabled (in your timezone).",
            'timezone_changed': "‚úÖ Timezone changed to: {tz}",
            'invalid_timezone': "‚ùå Unknown timezone: {tz}\n\nCheck spelling. Examples:\n‚Ä¢ Europe/Moscow\n‚Ä¢ America/New_York\n‚Ä¢ Asia/Tokyo",
            'timezone_already': "‚ÑπÔ∏è This timezone is already set:\n{tz}\n\nChoose another timezone or press /start to return to menu.",
            'language_set': "‚úÖ Language set to: {lang}",
            'custom_already_active': "‚úÖ Delivery at {time} is already active.",
            'custom_enabled': "‚úÖ Delivery at {time} enabled (in your timezone).",
            'invalid_time_range': "‚ùå Time must be between 00:00 and 23:59.",
        'topics_saved': "‚úÖ Topics saved! You will now receive quotes only for selected topics.",
        'btn_remove_all': "Remove all",
        'label_at_time': "At {time}",
        'choose_topics_prompt': "‚úÖ Choose topics you like.\nYou can select multiple:",
        'quotes_not_loaded': "Quotes are not loaded.",
        'no_quotes_in_topics': "No available quotes in selected topics. Choose other topics.",
        'stats_received': "üìä You received {n} quotes!",
    }
}

def get_msg(lang: str, key: str) -> str:
    return MESSAGES.get(lang, MESSAGES['ru']).get(key, MESSAGES['ru'].get(key, ''))

# –°–ª—É–∂–µ–±–Ω—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
AWAITING_TIME_TIMEOUT = 60
AUTOSAVE_INTERVAL = 300

# –ó–∞–≥—Ä—É–∑–∫–∞ —Ü–∏—Ç–∞—Ç –ø–æ —Ç–µ–º–∞–º
def load_quotes():
    """Load quotes for both Russian (default) and English (suffix _en)."""
    quotes = {'ru': {}, 'en': {}}
    current_dir = os.path.dirname(os.path.abspath(__file__))
    for theme in THEMES:
        # Russian
        file_path_ru = os.path.join(current_dir, f"quotes_{theme}.txt")
        try:
            with open(file_path_ru, "r", encoding="utf-8") as f:
                lines = [line.strip() for line in f if line.strip()]
                quotes['ru'][theme] = lines
                logger.info(f"Loaded {len(lines)} RU quotes for '{theme}'")
        except FileNotFoundError:
            quotes['ru'][theme] = []
            logger.warning(f"RU file {file_path_ru} not found for theme '{theme}'")

        # English
        file_path_en = os.path.join(current_dir, f"quotes_{theme}_en.txt")
        try:
            with open(file_path_en, "r", encoding="utf-8") as f:
                lines = [line.strip() for line in f if line.strip()]
                quotes['en'][theme] = lines
                logger.info(f"Loaded {len(lines)} EN quotes for '{theme}'")
        except FileNotFoundError:
            quotes['en'][theme] = []
            logger.warning(f"EN file {file_path_en} not found for theme '{theme}'")

    return quotes

# –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
def save_state(application):
    try:
        data = {}

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –≤—ã–±–æ—Ä —Ç–µ–º
        if 'user_stats' in application.bot_data:
            # JSON —Ç—Ä–µ–±—É–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –∫–ª—é—á–∏
            data['user_stats'] = {
                str(k): v for k, v in application.bot_data['user_stats'].items()
            }

        # –†–∞—Å—Å—ã–ª–∫–∏
        scheduled_jobs = []
        for job in application.job_queue.jobs():
            if job.data and "chat_id" in job.data:
                job_info = {
                    "chat_id": str(job.data["chat_id"]),
                    "type": job.data.get("job_type", "unknown")
                }
                if job.data.get("time"):
                    job_info["time"] = job.data["time"]
                if job.data.get("themes"):
                    job_info["themes"] = job.data["themes"]
                job_info["name"] = job.name
                scheduled_jobs.append(job_info)

        data['scheduled_jobs'] = scheduled_jobs

        with open(STATE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        logger.info("–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.")
    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %s", e)

async def save_state_job(context: ContextTypes.DEFAULT_TYPE):
    try:
        save_state(context.application)
    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %s", e)


def _remove_job_if_exists(job_queue, name):
    for j in job_queue.jobs():
        if j.name == name:
            j.schedule_removal()


def load_state(application):
    import shutil
    import datetime as _dt
    application.bot_data.setdefault('user_stats', {})

    # Try to open and parse the state file. If it's corrupt, back it up and start fresh.
    try:
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)

    except FileNotFoundError:
        logger.info("–§–∞–π–ª —Å–æ—Å—Ç–æ—è–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π.")
        application.bot_data['user_stats'] = {}
        return
    except json.JSONDecodeError as e:
        logger.exception("–§–∞–π–ª —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–≤—Ä–µ–∂–¥—ë–Ω (JSONDecodeError): %s", e)
        try:
            ts = _dt.datetime.now().strftime("%Y%m%d-%H%M%S")
            broken_name = f"{STATE_FILE}.broken-{ts}"
            shutil.copy2(STATE_FILE, broken_name)
            logger.info("–°–æ–∑–¥–∞–Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞: %s", broken_name)
        except Exception as ex:
            logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é –ø–æ–≤—Ä–µ–∂–¥—ë–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞: %s", ex)
        application.bot_data['user_stats'] = {}
        return
    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è: %s", e)
        application.bot_data['user_stats'] = {}
        return

    # –ï—Å–ª–∏ —á—Ç–µ–Ω–∏–µ –ø—Ä–æ—à–ª–æ —É—Å–ø–µ—à–Ω–æ ‚Äî –ø—Ä–∏–º–µ–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
    try:
        if 'user_stats' in data:
            # keys in file are strings -> convert to int
            application.bot_data['user_stats'] = {
                int(k): v for k, v in data['user_stats'].items()
            }
            # Ensure every user has a language set (migration for older files)
            for uid, us in application.bot_data['user_stats'].items():
                if 'lang' not in us:
                    us['lang'] = 'ru'

        # –†–∞—Å—Å—ã–ª–∫–∏
        if 'scheduled_jobs' in data:
            for job_info in data['scheduled_jobs']:
                chat_id = int(job_info["chat_id"])
                job_type = job_info["type"]
                time_str = job_info.get("time")
                themes = job_info.get("themes", list(THEMES.keys()))
                job_name = job_info.get("name") or f"{chat_id}_{job_type}_{time_str or 'unknown'}"

                _remove_job_if_exists(application.job_queue, job_name)

                user_stats = application.bot_data.get('user_stats', {}).get(chat_id, {})
                user_tz = user_stats.get('tz', MOSCOW_TZ)
                tzobj = pytz.timezone(user_tz) if user_tz.startswith("UTC") == False else parse_utc_offset(user_tz)

                if job_type == "hourly":
                    application.job_queue.run_repeating(
                        send_quote_job,
                        interval=3600,
                        first=60,
                        chat_id=chat_id,
                        name=job_name,
                        data={"chat_id": chat_id, "job_type": "hourly", "themes": themes}
                    )
                elif job_type == 'once' and time_str:
                    # one-shot job: schedule only if time still in the future
                    hour, minute = map(int, time_str.split(":"))
                    now = datetime.datetime.now(tzobj)
                    first_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
                    if first_time <= now:
                        logger.info("–ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ one-shot —Ä–∞—Å—Å—ã–ª–∫–∏ %s ‚Äî –≤—Ä–µ–º—è —É–∂–µ –ø—Ä–æ—à–ª–æ: %s", job_name, time_str)
                    else:
                        first_delay = (first_time - now).total_seconds()
                        application.job_queue.run_once(
                            send_quote_job,
                            when=first_delay,
                            chat_id=chat_id,
                            name=job_name,
                            data={"chat_id": chat_id, "job_type": "once", "time": time_str, "themes": themes}
                        )
                elif job_type in ("daily", "custom") and time_str:
                    hour, minute = map(int, time_str.split(":"))
                    send_time = dt_time(hour=hour, minute=minute, tzinfo=tzobj)
                    application.job_queue.run_daily(
                        send_quote_job,
                        time=send_time,
                        chat_id=chat_id,
                        name=job_name,
                        data={"chat_id": chat_id, "job_type": job_type, "time": time_str, "themes": themes}
                    )

        logger.info("–°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ.")
    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏—è: %s", e)
        application.bot_data['user_stats'] = {}

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
def is_spamming(chat_id: int) -> bool:
    now = time_module.time()
    USER_MESSAGE_TIMES[chat_id] = [t for t in USER_MESSAGE_TIMES[chat_id] if now - t < 10]
    if len(USER_MESSAGE_TIMES[chat_id]) >= 5:
        return True
    USER_MESSAGE_TIMES[chat_id].append(now)
    return False


def parse_utc_offset(utc_str: str):
    """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç UTC+3 –≤ timezone –æ–±—ä–µ–∫—Ç."""
    try:
        if utc_str.startswith("UTC"):
            offset_str = utc_str[3:]
            offset_hours = int(offset_str)
            return timezone(timedelta(hours=offset_hours))
    except:
        pass
    return timezone.utc


def parse_quote(quote_line: str):
    """–†–∞–∑–¥–µ–ª—è–µ—Ç —Ü–∏—Ç–∞—Ç—É –∏ –∞–≤—Ç–æ—Ä–∞ –ø–æ ' ‚Äî ' –∏–ª–∏ ' - '."""
    if " ‚Äî " in quote_line:
        text, author = quote_line.rsplit(" ‚Äî ", 1)
    elif " - " in quote_line:
        text, author = quote_line.rsplit(" - ", 1)
    else:
        text, author = quote_line, ""
    return text.strip('‚Äú‚Äù"'), author.strip()


async def send_quote_to_user(context: ContextTypes.DEFAULT_TYPE, chat_id: int, themes_list=None):
    async with USER_LOCKS[chat_id]:
        # Ensure user stats and language are available
        context.application.bot_data.setdefault('user_stats', {})
        user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
            "count": 0,
            "selected_topics": list(THEMES.keys()),
            "tz": MOSCOW_TZ,
            "lang": 'ru'
        })
        lang = user_stats.get('lang', 'ru')

        if not ALL_QUOTES:
            await context.bot.send_message(chat_id=chat_id, text=get_msg(lang, 'quotes_not_loaded'))
            return

        selected_topics = user_stats.get("selected_topics", list(THEMES.keys()))
        available_themes = themes_list or selected_topics
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ü–∏—Ç–∞—Ç—ã –¥–ª—è —Ç–µ–º –≤ —Ç–µ–∫—É—â–µ–º —è–∑—ã–∫–µ –∏–ª–∏ –≤ RU (fallback)
        def has_quotes_for_theme(t):
            return bool(ALL_QUOTES.get(lang, {}).get(t)) or bool(ALL_QUOTES.get('ru', {}).get(t))

        available_themes = [t for t in available_themes if has_quotes_for_theme(t)]
        if not available_themes:
            await context.bot.send_message(chat_id=chat_id, text=get_msg(lang, 'no_quotes_in_topics'))
            return

        user_stats["count"] = user_stats.get("count", 0) + 1

        import random
        chosen_theme = random.choice(available_themes)
        lang = user_stats.get('lang', 'ru')
        theme_quotes = ALL_QUOTES.get(lang, ALL_QUOTES.get('ru', {})).get(chosen_theme, [])
        if not theme_quotes:
            # fallback to ru if en list is empty
            theme_quotes = ALL_QUOTES.get('ru', {}).get(chosen_theme, [])

        quote_line = random.choice(theme_quotes)
        text, author = parse_quote(quote_line)

        emoji, theme_name = get_theme_parts(chosen_theme, lang)
        author_str = f"\n‚Äî *{tg_escape(author, version=2)}*" if author else ""

        message = (
            f"{emoji} *{tg_escape(theme_name, version=2)}*\n\n"
            f"_{tg_escape(text, version=2)}_"
            f"{author_str}\n\n"
        )

        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=message,
                parse_mode="MarkdownV2",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(get_msg(lang, 'btn_more_quote'), callback_data="more_quote")],
                ])
            )
        except Exception as e:
                logger.exception("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: %s", e)
                user_stats["count"] = max(0, user_stats["count"] - 1)


def get_topics_keyboard(selected):
    # kept for backward compatibility; prefer get_topics_keyboard_lang
    return get_topics_keyboard_lang(selected, 'ru')


def get_topics_keyboard_lang(selected, lang='ru'):
    buttons = []
    theme_labels = THEMES_EN if lang == 'en' else THEMES
    for theme_key, theme_name in theme_labels.items():
        mark = "‚úÖ" if theme_key in selected else "‚¨ú"
        buttons.append([InlineKeyboardButton(f"{mark} {theme_name}", callback_data=f"toggle_{theme_key}")])
    buttons.append([InlineKeyboardButton(get_msg(lang, 'btn_topics_done'), callback_data="topics_done")])
    return InlineKeyboardMarkup(buttons)


def get_theme_parts(theme_key: str, lang: str = 'ru'):
    labels = THEMES_EN if lang == 'en' else THEMES
    label = labels.get(theme_key, theme_key)
    parts = label.split(" ", 1)
    if len(parts) > 1:
        return parts[0], parts[1]
    return "", label


def get_main_keyboard(lang: str = 'ru'):
    return ReplyKeyboardMarkup(
        [   
            [KeyboardButton(get_msg(lang, 'btn_get_quote'))],
            [KeyboardButton(get_msg(lang, 'btn_create_delivery'))],
            [KeyboardButton(get_msg(lang, 'btn_choose_topics'))],
            [KeyboardButton(get_msg(lang, 'btn_manage_jobs')), KeyboardButton(get_msg(lang, 'btn_stats'))],
        ],
        resize_keyboard=True
    )


def get_timezone_keyboard():
    """–°–æ–∑–¥–∞—ë—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –≤—ã–±–æ—Ä–∞ —á–∞—Å–æ–≤–æ–≥–æ –ø–æ—è—Å–∞ –ø–æ UTC."""
    buttons = []
    for utc_key, utc_name in UTC_OFFSETS.items():
        buttons.append([InlineKeyboardButton(utc_name, callback_data=f"tz_{utc_key}")])
    return InlineKeyboardMarkup(buttons)


async def timezone_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
        "count": 0,
        "selected_topics": list(THEMES.keys()),
        "tz": MOSCOW_TZ
    })
    current_tz = user_stats.get("tz", MOSCOW_TZ)
    lang = user_stats.get('lang', 'ru')
    tz_display = UTC_OFFSETS.get(current_tz, current_tz)
    await update.message.reply_text(
        f"üåç {get_msg(lang, 'timezone_note')}\n\n"
        f"{tz_display}",
        reply_markup=get_timezone_keyboard()
    )


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    context.application.bot_data.setdefault('user_stats', {})
    user_stats = context.application.bot_data['user_stats'].get(chat_id, {})
    # If language is not set, ask language first
    if not user_stats or 'lang' not in user_stats:
        # Ask language first
        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("–†—É—Å—Å–∫–∏–π", callback_data="set_lang_ru"), InlineKeyboardButton("English", callback_data="set_lang_en")]
        ])
        await update.message.reply_text(get_msg('ru', 'choose_language'), reply_markup=kb)
        return
    # If timezone is not set, prompt timezone selection
    if 'tz' not in user_stats:
        lang = user_stats.get('lang', 'ru')
        tz_msg = get_msg(lang, 'timezone_note')
        await update.message.reply_text(f"üåç {tz_msg}", reply_markup=get_timezone_keyboard())
        return

    lang = user_stats.get('lang', 'ru')
    await update.message.reply_text(get_msg(lang, 'start_full'), reply_markup=get_main_keyboard(lang))



async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    stats_data = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
    count = stats_data.get("count", 0)
    chat_id = update.effective_chat.id
    user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
    lang = user_stats.get('lang', 'ru')
    await update.message.reply_text(get_msg(lang, 'stats_received').format(n=count))


async def language_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Command to change language."""
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton("–†—É—Å—Å–∫–∏–π", callback_data="set_lang_ru"), InlineKeyboardButton("English", callback_data="set_lang_en")]
    ])
    chat_id = update.effective_chat.id
    context.application.bot_data.setdefault('user_stats', {})
    user_stats = context.application.bot_data['user_stats'].get(chat_id, {})
    lang = user_stats.get('lang', 'ru')
    await update.message.reply_text(get_msg(lang, 'choose_language'), reply_markup=kb)


async def show_topic_selector(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    context.application.bot_data.setdefault('user_stats', {})
    user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
        "count": 0,
        "selected_topics": list(THEMES.keys()),
        "tz": MOSCOW_TZ
    })
    selected = user_stats.get("selected_topics", list(THEMES.keys()))
    lang = user_stats.get('lang', 'ru')
    await update.message.reply_text(
        get_msg(lang, 'choose_topics_prompt'),
        reply_markup=get_topics_keyboard_lang(selected, lang)
    )


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π."""
    chat_id = update.effective_chat.id
    # ensure user stats and language
    context.application.bot_data.setdefault('user_stats', {})
    user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {"count":0, "selected_topics": list(THEMES.keys()), "tz": MOSCOW_TZ, "lang": 'ru'})
    lang = user_stats.get('lang', 'ru')

    if is_spamming(chat_id):
        await update.message.reply_text(get_msg(lang, 'spam'))
        return

    text = update.message.text

    if text == get_msg(lang, 'btn_get_quote'):
        await send_quote_to_user(context, chat_id)
        save_state(context.application)

    elif text == get_msg(lang, 'btn_create_delivery'):
        # Start creation flow: choose frequency
        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton(get_msg(lang, 'freq_hourly'), callback_data="cd_freq_hourly")],
            [InlineKeyboardButton(get_msg(lang, 'freq_daily'), callback_data="cd_freq_daily")],
            [InlineKeyboardButton(get_msg(lang, 'freq_once'), callback_data="cd_freq_once")]
        ])
        await update.message.reply_text(get_msg(lang, 'choose_frequency'), reply_markup=kb)
        return

    elif text == get_msg(lang, 'btn_choose_topics'):
        await show_topic_selector(update, context)
    elif text == get_msg(lang, 'btn_stats'):
        await stats(update, context)

    elif text == get_msg(lang, 'btn_hourly'):
        job_name = f"{chat_id}_hourly"
        existing = [j for j in context.job_queue.jobs() if j.name == job_name]
        if existing:
            await update.message.reply_text(get_msg(lang, 'hourly_already'))
        else:
            context.user_data["awaiting_hourly_time"] = True
            context.user_data["awaiting_hourly_time_ts"] = time_module.time() + AWAITING_TIME_TIMEOUT
            await update.message.reply_text(get_msg(lang, 'prompt_hourly_time'))
    elif context.user_data.get("awaiting_hourly_time"):
        expiry = context.user_data.get("awaiting_hourly_time_ts", 0)
        if time_module.time() > expiry:
            context.user_data.pop("awaiting_hourly_time", None)
            context.user_data.pop("awaiting_hourly_time_ts", None)
            await update.message.reply_text(get_msg(lang, 'awaiting_time_expired'))
            return

        context.user_data.pop("awaiting_hourly_time", None)
        context.user_data.pop("awaiting_hourly_time_ts", None)
        if re.match(r"^\d{1,2}:\d{2}$", text):
            try:
                hour, minute = map(int, text.split(":"))
                if 0 <= hour <= 23 and 0 <= minute <= 59:
                    user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {"count":0, "selected_topics": list(THEMES.keys()), "tz": MOSCOW_TZ})
                    user_tz = user_stats.get('tz', MOSCOW_TZ)
                    tzobj = pytz.timezone(user_tz) if not user_tz.startswith("UTC") else parse_utc_offset(user_tz)
                    job_name = f"{chat_id}_hourly"
                    _remove_job_if_exists(context.job_queue, job_name)
                    now = datetime.datetime.now(tzobj)
                    # –í—ã—á–∏—Å–ª—è–µ–º –≤—Ä–µ–º—è –¥–æ –ø–µ—Ä–≤–æ–≥–æ –∑–∞–ø—É—Å–∫–∞
                    first_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
                    if first_time < now:
                        first_time += timedelta(days=1)
                    first_delay = (first_time - now).total_seconds()
                    context.job_queue.run_repeating(
                        send_quote_job,
                        interval=3600,
                        first=first_delay,
                        chat_id=chat_id,
                        name=job_name,
                        data={
                            "chat_id": chat_id,
                            "job_type": "hourly",
                            "themes": user_stats.get('selected_topics', list(THEMES.keys())),
                            "start_time": f"{hour:02d}:{minute:02d}"
                        }
                    )
                    save_state(context.application)
                    await update.message.reply_text(get_msg(lang, 'hourly_enabled_first').format(time=first_time.strftime('%H:%M')))
                else:
                    raise ValueError
            except ValueError:
                await update.message.reply_text(get_msg(lang, 'invalid_time_format'))
        else:
            await update.message.reply_text(get_msg(lang, 'invalid_time_format'))

    # Note: new-delivery inline callbacks and time-input flow removed per user request
    # Re-added: handle awaiting input for new delivery time
    elif context.user_data.get('awaiting_new_delivery_time'):
        expiry = context.user_data.get('awaiting_new_delivery_time_ts', 0)
        if time_module.time() > expiry:
            context.user_data.pop('awaiting_new_delivery_time', None)
            context.user_data.pop('awaiting_new_delivery_time_ts', None)
            context.user_data.pop('new_delivery', None)
            await update.message.reply_text(get_msg(lang, 'awaiting_time_expired'))
            return

        context.user_data.pop('awaiting_new_delivery_time', None)
        context.user_data.pop('awaiting_new_delivery_time_ts', None)
        new_delivery = context.user_data.pop('new_delivery', {})
        freq = new_delivery.get('freq')
        if not freq:
            await update.message.reply_text(get_msg(lang, 'unknown_command'))
            return

        if re.match(r"^\d{1,2}:\d{2}$", text):
            try:
                hour, minute = map(int, text.split(":"))
                if not (0 <= hour <= 23 and 0 <= minute <= 59):
                    raise ValueError

                user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {"count":0, "selected_topics": list(THEMES.keys()), "tz": MOSCOW_TZ})
                user_tz = user_stats.get('tz', MOSCOW_TZ)
                tzobj = pytz.timezone(user_tz) if not user_tz.startswith("UTC") else parse_utc_offset(user_tz)

                if freq == 'hourly':
                    # schedule repeating every hour, compute first delay
                    now = datetime.datetime.now(tzobj)
                    first_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
                    if first_time < now:
                        first_time += timedelta(days=1)
                    first_delay = (first_time - now).total_seconds()
                    job_name = f"{chat_id}_delivery_hourly_{hour:02d}{minute:02d}"
                    _remove_job_if_exists(context.job_queue, job_name)
                    context.job_queue.run_repeating(
                        send_quote_job,
                        interval=3600,
                        first=first_delay,
                        chat_id=chat_id,
                        name=job_name,
                        data={"chat_id": chat_id, "job_type": "hourly", "time": f"{hour:02d}:{minute:02d}", "themes": user_stats.get('selected_topics', list(THEMES.keys()))}
                    )

                elif freq == 'once':
                    # One-time delivery -> schedule single run
                    now = datetime.datetime.now(tzobj)
                    first_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
                    if first_time < now:
                        first_time += timedelta(days=1)
                    first_delay = (first_time - now).total_seconds()
                    job_name = f"{chat_id}_delivery_once_{hour:02d}{minute:02d}"
                    _remove_job_if_exists(context.job_queue, job_name)
                    context.job_queue.run_once(
                        send_quote_job,
                        when=first_delay,
                        chat_id=chat_id,
                        name=job_name,
                        data={"chat_id": chat_id, "job_type": "once", "time": f"{hour:02d}:{minute:02d}", "themes": user_stats.get('selected_topics', list(THEMES.keys()))}
                    )

                else:
                    # daily or custom -> schedule daily at specified time
                    send_time = dt_time(hour=hour, minute=minute, tzinfo=tzobj)
                    job_type = 'daily' if freq == 'daily' else 'custom'
                    job_name = f"{chat_id}_delivery_{job_type}_{hour:02d}{minute:02d}"
                    _remove_job_if_exists(context.job_queue, job_name)
                    context.job_queue.run_daily(
                        send_quote_job,
                        time=send_time,
                        chat_id=chat_id,
                        name=job_name,
                        data={"chat_id": chat_id, "job_type": job_type, "time": f"{hour:02d}:{minute:02d}", "themes": user_stats.get('selected_topics', list(THEMES.keys()))}
                    )

                save_state(context.application)
                freq_label = get_msg(lang, 'freq_' + freq)
                await update.message.reply_text(get_msg(lang, 'confirm_create_delivery').format(freq=freq_label, time=f"{hour:02d}:{minute:02d}"))
            except ValueError:
                await update.message.reply_text(get_msg(lang, 'invalid_time_range'))
        else:
            await update.message.reply_text(get_msg(lang, 'invalid_time_format'))

    elif text == get_msg(lang, 'btn_daily_7'):
        user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {"count":0, "selected_topics": list(THEMES.keys()), "tz": MOSCOW_TZ})
        user_tz = user_stats.get('tz', MOSCOW_TZ)
        tzobj = pytz.timezone(user_tz) if not user_tz.startswith("UTC") else parse_utc_offset(user_tz)

        job_name = f"{chat_id}_daily_07-00"
        existing = [j for j in context.job_queue.jobs() if j.name == job_name]
        if existing:
            await update.message.reply_text(get_msg(lang, 'hourly_already'))
        else:
            _remove_job_if_exists(context.job_queue, job_name)
            send_time = dt_time(hour=7, minute=0, tzinfo=tzobj)
            context.job_queue.run_daily(
                send_quote_job,
                time=send_time,
                chat_id=chat_id,
                name=job_name,
                data={"chat_id": chat_id, "job_type": "daily", "time": "07:00", "themes": user_stats.get('selected_topics', list(THEMES.keys()))}
            )
            save_state(context.application)
            await update.message.reply_text(get_msg(lang, 'daily_enabled').format(time="07:00"))

    elif text == get_msg(lang, 'btn_choose_time'):
        context.user_data["awaiting_time"] = True
        context.user_data["awaiting_time_ts"] = time_module.time() + AWAITING_TIME_TIMEOUT
        await update.message.reply_text(get_msg(lang, 'prompt_custom_time'))

    elif text == get_msg(lang, 'btn_manage_jobs'):
        jobs = [j for j in context.job_queue.jobs() if j.data and j.data.get("chat_id") == chat_id]
        if not jobs:
            await update.message.reply_text(get_msg(lang, 'no_active_jobs'))
        else:
            buttons = []
            for job in jobs:
                job_type = job.data.get("job_type", "unknown")
                time_str = job.data.get("time", "")
                if job_type == "hourly":
                    if time_str:
                        label = f"{get_msg(lang, 'btn_hourly')} ({time_str})"
                    else:
                        label = get_msg(lang, 'btn_hourly')
                else:
                    label = get_msg(lang, 'label_at_time').format(time=time_str)
                buttons.append([InlineKeyboardButton(f"‚ùå {label}", callback_data=f"remove_{job.name}")])
            buttons.append([InlineKeyboardButton(f"‚ùå {get_msg(lang, 'btn_remove_all')}", callback_data="remove_all")])
            try:
                await update.message.reply_text(
                    get_msg(lang, 'choose_job_to_disable'),
                    reply_markup=InlineKeyboardMarkup(buttons)
                )
            except Exception as e:
                logger.warning("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–ø–∏—Å–∫–∞ —Ä–∞—Å—Å—ã–ª–æ–∫ (–ø–æ–ø—ã—Ç–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏): %s", e)
                try:
                    await asyncio.sleep(1)
                    await update.message.reply_text(
                        get_msg(lang, 'choose_job_to_disable'),
                        reply_markup=InlineKeyboardMarkup(buttons)
                    )
                except Exception:
                    logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ —Ä–∞—Å—Å—ã–ª–æ–∫ –ø–æ—Å–ª–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏.")

    else:
        if context.user_data.get("awaiting_timezone"):
            expiry = context.user_data.get("awaiting_tz_ts", 0)
            if time_module.time() > expiry:
                context.user_data.pop("awaiting_timezone", None)
                context.user_data.pop("awaiting_tz_ts", None)
                await update.message.reply_text(get_msg(lang, 'awaiting_time_expired'))
                return

            context.user_data.pop("awaiting_timezone", None)
            context.user_data.pop("awaiting_tz_ts", None)
            
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –≤–∞–ª–∏–¥–Ω—ã–º —á–∞—Å–æ–≤—ã–º –ø–æ—è—Å–æ–º
                if not text.startswith("UTC"):
                    test_tz = pytz.timezone(text)
                else:
                    test_tz = parse_utc_offset(text)
                
                user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
                    "count": 0,
                    "selected_topics": list(THEMES.keys()),
                    "tz": MOSCOW_TZ
                })
                user_stats["tz"] = text
                save_state(context.application)
                await update.message.reply_text(get_msg(lang, 'timezone_changed').format(tz=text))
            except pytz.exceptions.UnknownTimeZoneError:
                await update.message.reply_text(get_msg(lang, 'invalid_timezone').format(tz=text))
            return

        if context.user_data.get("awaiting_time"):
            expiry = context.user_data.get("awaiting_time_ts", 0)
            if time_module.time() > expiry:
                context.user_data.pop("awaiting_time", None)
                context.user_data.pop("awaiting_time_ts", None)
                await update.message.reply_text(get_msg(lang, 'awaiting_time_expired'))
                return

            context.user_data.pop("awaiting_time", None)
            context.user_data.pop("awaiting_time_ts", None)
            if re.match(r"^\d{1,2}:\d{2}$", text):
                try:
                    hour, minute = map(int, text.split(":"))
                    if 0 <= hour <= 23 and 0 <= minute <= 59:
                        time_str = f"{hour:02d}:{minute:02d}"
                        job_name = f"{chat_id}_custom_{time_str.replace(':', '-')}"
                        existing = [j for j in context.job_queue.jobs() if j.name == job_name]
                        if existing:
                            await update.message.reply_text(get_msg(lang, 'custom_already_active').format(time=time_str))
                        else:
                            user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {"count":0, "selected_topics": list(THEMES.keys()), "tz": MOSCOW_TZ})
                            user_tz = user_stats.get('tz', MOSCOW_TZ)
                            tzobj = pytz.timezone(user_tz) if not user_tz.startswith("UTC") else parse_utc_offset(user_tz)
                            send_time = dt_time(hour=hour, minute=minute, tzinfo=tzobj)

                            _remove_job_if_exists(context.job_queue, job_name)
                            context.job_queue.run_daily(
                                send_quote_job,
                                time=send_time,
                                chat_id=chat_id,
                                name=job_name,
                                data={"chat_id": chat_id, "job_type": "custom", "time": time_str, "themes": user_stats.get('selected_topics', list(THEMES.keys()))}
                            )
                            save_state(context.application)
                            await update.message.reply_text(get_msg(lang, 'custom_enabled').format(time=time_str))
                    else:
                        raise ValueError
                except ValueError:
                    await update.message.reply_text(get_msg(lang, 'invalid_time_range'))
            else:
                await update.message.reply_text(get_msg(lang, 'invalid_time_format'))
        else:
            await update.message.reply_text(get_msg(lang, 'unknown_command'), reply_markup=get_main_keyboard(lang))


async def send_quote_job(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data or {}
    job_type = job_data.get('job_type')
    chat_id = job_data.get("chat_id") or context.job.chat_id
    user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
    themes = job_data.get("themes") or user_stats.get("selected_topics", list(THEMES.keys()))

    try:
        await send_quote_to_user(context, chat_id, themes)
    finally:
        # If this was a one-time delivery, ensure it's removed and state is saved
        if job_type == 'once':
            try:
                # schedule_removal is safe even if job already completed
                context.job.schedule_removal()
            except Exception:
                pass
            try:
                save_state(context.application)
            except Exception:
                logger.exception('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è one-shot —Ä–∞—Å—Å—ã–ª–∫–∏')


async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    chat_id = update.effective_chat.id

    if data == "more_quote":
        await send_quote_to_user(context, chat_id)

    elif data == "remove_all":
        jobs = [j for j in context.job_queue.jobs() if j.data and j.data.get("chat_id") == chat_id]
        for job in jobs:
            job.schedule_removal()
        user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
        lang = user_stats.get('lang', 'ru')
        await query.edit_message_text(get_msg(lang, 'removed_jobs').format(n=len(jobs)))

    elif data.startswith("remove_"):
        job_name = data.replace("remove_", "")
        jobs = [j for j in context.job_queue.jobs() if j.name == job_name]
        if jobs:
            jobs[0].schedule_removal()
            user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
            lang = user_stats.get('lang', 'ru')
            await query.edit_message_text(get_msg(lang, 'job_disabled'))
        else:
            user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
            lang = user_stats.get('lang', 'ru')
            await query.edit_message_text(get_msg(lang, 'job_already_disabled'))

    elif data == "topics_done":
        save_state(context.application)
        user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
        lang = user_stats.get('lang', 'ru')
        await query.edit_message_text(get_msg(lang, 'topics_saved'))
    
    elif data.startswith("tz_"):
        tz_key = data.replace("tz_", "")
        
        if tz_key.startswith("UTC"):
            user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
                "count": 0,
                "selected_topics": list(THEMES.keys()),
                "tz": MOSCOW_TZ
            })
            current_tz = user_stats.get("tz", MOSCOW_TZ)
            tz_display = UTC_OFFSETS.get(tz_key, tz_key)
            
            user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
            lang = user_stats.get('lang', 'ru')
            if current_tz == tz_key:
                await query.edit_message_text(get_msg(lang, 'timezone_already').format(tz=tz_display), reply_markup=get_timezone_keyboard())
            else:
                user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
                    "count": 0,
                    "selected_topics": list(THEMES.keys()),
                    "tz": MOSCOW_TZ
                })
                user_stats["tz"] = tz_key
                save_state(context.application)
                await query.edit_message_text(get_msg(lang, 'timezone_changed').format(tz=tz_display))

    # Note: create-delivery callbacks removed per user request
    elif data.startswith("cd_"):
        # create-delivery callbacks
        # selected a frequency
        freq = None
        if data == "cd_freq_hourly":
            freq = 'hourly'
        elif data == "cd_freq_daily":
            freq = 'daily'
        elif data == "cd_freq_once":
            freq = 'once'

        if freq:
            # store selection and ask for start time
            context.user_data['new_delivery'] = {'freq': freq}
            user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
            lang = user_stats.get('lang', 'ru')
            await query.edit_message_text(f"{get_msg(lang, 'create_delivery_title')} ‚Äî {get_msg(lang, 'freq_' + freq)}")
            await context.bot.send_message(chat_id=chat_id, text=get_msg(lang, 'enter_start_time_freq'))
            context.user_data['awaiting_new_delivery_time'] = True
            context.user_data['awaiting_new_delivery_time_ts'] = time_module.time() + AWAITING_TIME_TIMEOUT
            return

    elif data.startswith("set_lang_"):
        lang_code = data.replace("set_lang_", "")
        if lang_code in LANGUAGES:
            # Do not force a default tz here: keep tz absent so we can prompt user to pick it
            user_stats = context.application.bot_data['user_stats'].get(chat_id)
            if not user_stats:
                context.application.bot_data['user_stats'][chat_id] = {
                    "count": 0,
                    "selected_topics": list(THEMES.keys()),
                    "lang": lang_code
                }
                user_stats = context.application.bot_data['user_stats'][chat_id]
            else:
                user_stats['lang'] = lang_code

            save_state(context.application)
            # confirm in the newly selected language
            await query.edit_message_text(get_msg(lang_code, 'language_set').format(lang=LANGUAGES[lang_code]))
            # If timezone not set, ask for timezone selection next
            if 'tz' not in user_stats:
                await context.bot.send_message(chat_id=chat_id, text=get_msg(lang_code, 'timezone_note'), reply_markup=get_timezone_keyboard())
    
    elif data.startswith("toggle_"):
        theme_key = data.replace("toggle_", "")
        if theme_key in THEMES:
            user_stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
                "count": 0,
                "selected_topics": list(THEMES.keys()),
                "tz": MOSCOW_TZ
            })
            selected = user_stats.setdefault("selected_topics", list(THEMES.keys()))
            if theme_key in selected:
                selected.remove(theme_key)
            else:
                selected.append(theme_key)
            save_state(context.application)
            user_stats = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
            lang = user_stats.get('lang', 'ru')
            await query.edit_message_reply_markup(reply_markup=get_topics_keyboard_lang(selected, lang))


# –ó–∞–ø—É—Å–∫
def main():
    global ALL_QUOTES
    ALL_QUOTES = load_quotes()

    application = Application.builder().token(BOT_TOKEN).build()
    load_state(application)

    application.job_queue.run_repeating(save_state_job, interval=AUTOSAVE_INTERVAL, first=AUTOSAVE_INTERVAL)

    def signal_handler(signum, frame):
        logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ...")
        save_state(application)
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("stats", stats))
    application.add_handler(CommandHandler("timezone", timezone_command))
    application.add_handler(CommandHandler("language", language_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(button_handler))

    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    try:
        application.run_polling()
    except KeyboardInterrupt:
        logger.info("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ (Ctrl+C). –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ...")
        save_state(application)
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")


if __name__ == "__main__":
    main()    return quotes

# === –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è ===
def save_state(application):
    try:
        data = {}

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –≤—ã–±–æ—Ä —Ç–µ–º
        if 'user_stats' in application.bot_data:
            data['user_stats'] = application.bot_data['user_stats']

        # –†–∞—Å—Å—ã–ª–∫–∏
        scheduled_jobs = []
        for job in application.job_queue.jobs():
            if job.data and "chat_id" in job.data:
                job_info = {
                    "chat_id": str(job.data["chat_id"]),
                    "type": job.data.get("job_type", "unknown")
                }
                if job.data.get("time"):
                    job_info["time"] = job.data["time"]
                if job.data.get("themes"):
                    job_info["themes"] = job.data["themes"]
                scheduled_jobs.append(job_info)

        data['scheduled_jobs'] = scheduled_jobs

        with open(STATE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        logger.info("–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.")
    except Exception as e:
        logger.error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: %s", e)

def load_state(application):
    application.bot_data.setdefault('user_stats', {})  # <-- –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –Ω–∞–ª–∏—á–∏–µ
    try:
        with open(STATE_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)

        if 'user_stats' in data:
            application.bot_data['user_stats'] = {
                int(k): {
                    "count": v.get("count", 0),
                    "selected_topics": v.get("selected_topics", list(THEMES.keys()))
                }
                for k, v in data['user_stats'].items()
            }

        # –†–∞—Å—Å—ã–ª–∫–∏
        if 'scheduled_jobs' in application.bot_data:
            for job_info in data['scheduled_jobs']:
                chat_id = int(job_info["chat_id"])
                job_type = job_info["type"]
                time_str = job_info.get("time")
                themes = job_info.get("themes", list(THEMES.keys()))

                if job_type == "hourly":
                    application.job_queue.run_repeating(
                        send_quote_job,
                        interval=3600,
                        first=60,
                        chat_id=chat_id,
                        name=f"{chat_id}_hourly",
                        data={"chat_id": chat_id, "job_type": "hourly", "themes": themes}
                    )
                elif job_type in ("daily", "custom") and time_str:
                    hour, minute = map(int, time_str.split(":"))
                    send_time = time(hour=hour, minute=minute, tzinfo=MOSCOW_TZ)
                    application.job_queue.run_daily(
                        send_quote_job,
                        time=send_time,
                        chat_id=chat_id,
                        name=f"{chat_id}_{job_type}_{time_str.replace(':', '-')}",
                        data={"chat_id": chat_id, "job_type": job_type, "time": time_str, "themes": themes}
                    )

        logger.info("–°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ.")
    except FileNotFoundError:
        logger.info("–§–∞–π–ª —Å–æ—Å—Ç–æ—è–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π.")
        application.bot_data['user_stats'] = {}
    except Exception as e:
        logger.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: %s", e)
        application.bot_data['user_stats'] = {}

# === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===
def is_spamming(chat_id: int) -> bool:
    import time
    now = time.time()
    USER_MESSAGE_TIMES[chat_id] = [t for t in USER_MESSAGE_TIMES[chat_id] if now - t < 10]
    if len(USER_MESSAGE_TIMES[chat_id]) >= 5:
        return True
    USER_MESSAGE_TIMES[chat_id].append(now)
    return False

def parse_quote(quote_line: str):
    """–†–∞–∑–¥–µ–ª—è–µ—Ç —Ü–∏—Ç–∞—Ç—É –∏ –∞–≤—Ç–æ—Ä–∞ –ø–æ ' ‚Äî ' –∏–ª–∏ ' - '."""
    if " ‚Äî " in quote_line:
        text, author = quote_line.rsplit(" ‚Äî ", 1)
    elif " - " in quote_line:
        text, author = quote_line.rsplit(" - ", 1)
    else:
        text, author = quote_line, ""
    return text.strip('‚Äú‚Äù"'), author.strip()

def escape_markdown_v2(text: str) -> str:
    """–≠–∫—Ä–∞–Ω–∏—Ä—É–µ—Ç —Å–ø–µ—Ü—Å–∏–º–≤–æ–ª—ã –¥–ª—è MarkdownV2."""
    escape_chars = r'\_*[]()~`>#+-=|{}.!'
    for char in escape_chars:
        text = text.replace(char, '\\' + char)
    return text

async def send_quote_to_user(context: ContextTypes.DEFAULT_TYPE, chat_id: int, themes_list=None):
    if not ALL_QUOTES:
        await context.bot.send_message(chat_id=chat_id, text="–¶–∏—Ç–∞—Ç—ã –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.")
        return

    # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞—ë–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
        "count": 0,
        "selected_topics": list(THEMES.keys())
    })
    stats["count"] += 1

    # –¢–µ–º—ã –¥–ª—è –≤—ã–±–æ—Ä–∞
    available_themes = themes_list or stats.get("selected_topics", list(THEMES.keys()))
    if not available_themes:
        available_themes = list(THEMES.keys())

    # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Ç–µ–º—É –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö
    import random
    chosen_theme = random.choice(available_themes)
    theme_quotes = ALL_QUOTES.get(chosen_theme, [])
    if not theme_quotes:
        await context.bot.send_message(chat_id=chat_id, text="–¶–∏—Ç–∞—Ç—ã –≤ —ç—Ç–æ–π —Ç–µ–º–µ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å.")
        return

    quote_line = random.choice(theme_quotes)
    text, author = parse_quote(quote_line)

    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º
    theme_name = THEMES[chosen_theme].split(" ", 1)[1]
    emoji = THEMES[chosen_theme].split(" ", 1)[0]
    author_str = f"\n‚Äî *{escape_markdown_v2(author)}*" if author else ""

    message = (
        f"{emoji} **{escape_markdown_v2(theme_name)}**\n\n"
        f"*‚Äú{escape_markdown_v2(text)}‚Äù*"
        f"{author_str}\n\n"
    )

    await context.bot.send_message(
        chat_id=chat_id,
        text=message,
        parse_mode="MarkdownV2",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üîÑ –ï—â—ë —Ü–∏—Ç–∞—Ç—É", callback_data="more_quote")],
        ])
    )

def get_main_keyboard():
    return ReplyKeyboardMarkup(
        [
            [KeyboardButton("‚ú® –ü–æ–ª—É—á–∏—Ç—å —Ü–∏—Ç–∞—Ç—É")],
            [KeyboardButton("üìö –í—ã–±—Ä–∞—Ç—å —Ç–µ–º—ã")],
            [KeyboardButton("‚è∞ –ï–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 7:00")],
            [KeyboardButton("üïí –í—ã–±—Ä–∞—Ç—å —Å–≤–æ—ë –≤—Ä–µ–º—è")],
            [KeyboardButton("üìÖ –ö–∞–∂–¥—ã–π —á–∞—Å")],
            [KeyboardButton("üõë –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∞–º–∏"), KeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")],
        ],
        resize_keyboard=True
    )

def get_topics_keyboard(selected):
    buttons = []
    for theme_key, theme_name in THEMES.items():
        mark = "‚úÖ" if theme_key in selected else "‚¨ú"
        buttons.append([InlineKeyboardButton(f"{mark} {theme_name}", callback_data=f"toggle_{theme_key}")])
    buttons.append([InlineKeyboardButton("‚úîÔ∏è –ì–æ—Ç–æ–≤–æ", callback_data="topics_done")])
    return InlineKeyboardMarkup(buttons)

# === –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ ===
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–ü—Ä–∏–≤–µ—Ç! üåü –Ø ‚Äî –±–æ—Ç –≤–¥–æ—Ö–Ω–æ–≤–ª—è—é—â–∏—Ö —Ü–∏—Ç–∞—Ç.\n\n"
        "–í—ã–±–µ—Ä–∏ —Ç–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ç–µ–±–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã, –∏ –ø–æ–ª—É—á–∞–π –º—É–¥—Ä–æ—Å—Ç—å, –º–æ—Ç–∏–≤–∞—Ü–∏—é –∏–ª–∏ –ª—é–±–æ–≤—å –∫–∞–∂–¥—ã–π –¥–µ–Ω—å üí¨",
        reply_markup=get_main_keyboard()
    )

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    stats_data = context.application.bot_data.get('user_stats', {}).get(chat_id, {})
    count = stats_data.get("count", 0)
    await update.message.reply_text(f"üìä –¢—ã –ø–æ–ª—É—á–∏–ª(–∞) {count} —Ü–∏—Ç–∞—Ç!")

async def show_topic_selector(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ user_stats —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    context.application.bot_data.setdefault('user_stats', {})
    stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
        "count": 0,
        "selected_topics": list(THEMES.keys())
    })
    selected = stats.get("selected_topics", list(THEMES.keys()))
    await update.message.reply_text(
        "‚úÖ –í—ã–±–µ—Ä–∏ —Ç–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ç–µ–±–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã.\n–ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ:",
        reply_markup=get_topics_keyboard(selected)
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if is_spamming(update.effective_chat.id):
        await update.message.reply_text("‚è≥ –ù–µ —Å–ø–∞–º–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞.")
        return

    text = update.message.text
    chat_id = update.effective_chat.id

    if text == "‚ú® –ü–æ–ª—É—á–∏—Ç—å —Ü–∏—Ç–∞—Ç—É":
        await send_quote_to_user(context, chat_id)

    elif text == "üìö –í—ã–±—Ä–∞—Ç—å —Ç–µ–º—ã":
        await show_topic_selector(update, context)

    elif text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞":
        await stats(update, context)

    elif text == "üìÖ –ö–∞–∂–¥—ã–π —á–∞—Å":
        job_name = f"{chat_id}_hourly"
        existing = [j for j in context.job_queue.jobs() if j.name == job_name]
        if existing:
            await update.message.reply_text("‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–ö–∞–∂–¥—ã–π —á–∞—Å¬ª —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞.")
        else:
            user_stats_data = context.application.bot_data['user_stats'].get(chat_id, {})
            themes = user_stats_data.get("selected_topics", list(THEMES.keys()))  # ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û
            context.job_queue.run_repeating(
                send_quote_job,
                interval=3600,
                first=1,
                chat_id=chat_id,
                name=job_name,
                data={"chat_id": chat_id, "job_type": "hourly", "themes": themes}
            )
            await update.message.reply_text("‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–ö–∞–∂–¥—ã–π —á–∞—Å¬ª –≤–∫–ª—é—á–µ–Ω–∞ (–ø–æ –ú–°–ö).")

    elif text == "‚è∞ –ï–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 7:00":
        job_name = f"{chat_id}_daily_07-00"
        existing = [j for j in context.job_queue.jobs() if j.name == job_name]
        if existing:
            await update.message.reply_text("‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞.")
        else:
            user_stats_data = context.application.bot_data['user_stats'].get(chat_id, {})
            themes = user_stats_data.get("selected_topics", list(THEMES.keys()))  # ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û
            send_time = time(hour=7, minute=0, tzinfo=MOSCOW_TZ)
            context.job_queue.run_daily(
                send_quote_job,
                time=send_time,
                chat_id=chat_id,
                name=job_name,
                data={"chat_id": chat_id, "job_type": "daily", "time": "07:00", "themes": themes}
            )
            await update.message.reply_text("‚úÖ –ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –≤ 7:00 –ø–æ –ú–°–ö –≤–∫–ª—é—á–µ–Ω–∞.")

    elif text == "üïí –í—ã–±—Ä–∞—Ç—å —Å–≤–æ—ë –≤—Ä–µ–º—è":
        USER_STATE[chat_id] = "awaiting_time"
        await update.message.reply_text("–ù–∞–ø–∏—à–∏ –≤—Ä–µ–º—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (–ø–æ –ú–°–ö).\n–ü—Ä–∏–º–µ—Ä: 14:30")

    elif text == "üõë –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å—Å—ã–ª–∫–∞–º–∏":
        jobs = [j for j in context.job_queue.jobs() if j.data and j.data.get("chat_id") == chat_id]
        if not jobs:
            await update.message.reply_text("–£ —Ç–µ–±—è –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–∞—Å—Å—ã–ª–æ–∫.")
        else:
            buttons = []
            for job in jobs:
                job_type = job.data.get("job_type", "unknown")
                time_str = job.data.get("time", "")
                if job_type == "hourly":
                    label = "–ö–∞–∂–¥—ã–π —á–∞—Å"
                else:
                    label = f"–í {time_str}"
                buttons.append([InlineKeyboardButton(f"‚ùå {label}", callback_data=f"remove_{job.name}")])
            buttons.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∏—Ç—å –≤—Å—ë", callback_data="remove_all")])
            await update.message.reply_text(
                "–í—ã–±–µ—Ä–∏ —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è:",
                reply_markup=InlineKeyboardMarkup(buttons)
            )

    else:
        if USER_STATE.get(chat_id) == "awaiting_time":
            del USER_STATE[chat_id]
            if re.match(r"^\d{1,2}:\d{2}$", text):
                try:
                    hour, minute = map(int, text.split(":"))
                    if 0 <= hour <= 23 and 0 <= minute <= 59:
                        time_str = f"{hour:02d}:{minute:02d}"
                        job_name = f"{chat_id}_custom_{time_str.replace(':', '-')}"
                        existing = [j for j in context.job_queue.jobs() if j.name == job_name]
                        if existing:
                            await update.message.reply_text(f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–í {time_str}¬ª —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞.")
                        else:
                            user_stats_data = context.application.bot_data['user_stats'].get(chat_id, {})
                            themes = user_stats_data.get("selected_topics", list(THEMES.keys()))  # ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û
                            send_time = time(hour=hour, minute=minute, tzinfo=MOSCOW_TZ)
                            context.job_queue.run_daily(
                                send_quote_job,
                                time=send_time,
                                chat_id=chat_id,
                                name=job_name,
                                data={"chat_id": chat_id, "job_type": "custom", "time": time_str, "themes": themes}
                            )
                            await update.message.reply_text(f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ ¬´–í {time_str} –ø–æ –ú–°–ö¬ª –≤–∫–ª—é—á–µ–Ω–∞.")
                    else:
                        raise ValueError
                except ValueError:
                    await update.message.reply_text("‚ùå –í—Ä–µ–º—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 00:00 –¥–æ 23:59.")
            else:
                await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü—Ä–∏–º–µ—Ä: 14:30")
        else:
            await update.message.reply_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞.", reply_markup=get_main_keyboard())

async def send_quote_job(context: ContextTypes.DEFAULT_TYPE):
    chat_id = context.job.data["chat_id"]
    themes = context.job.data.get("themes", list(THEMES.keys()))
    await send_quote_to_user(context, chat_id, themes)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    chat_id = update.effective_chat.id

    if data == "more_quote":
        await send_quote_to_user(context, chat_id)

    elif data == "remove_all":
        jobs = [j for j in context.job_queue.jobs() if j.data and j.data.get("chat_id") == chat_id]
        for job in jobs:
            job.schedule_removal()
        await query.edit_message_text(f"‚èπ –û—Ç–∫–ª—é—á–µ–Ω–æ {len(jobs)} —Ä–∞—Å—Å—ã–ª–æ–∫.")

    elif data.startswith("remove_"):
        job_name = data.replace("remove_", "")
        jobs = [j for j in context.job_queue.jobs() if j.name == job_name]
        if jobs:
            jobs[0].schedule_removal()
            await query.edit_message_text("‚èπ –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞.")
        else:
            await query.edit_message_text("–†–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –æ—Ç–∫–ª—é—á–µ–Ω–∞.")

    elif data == "topics_done":
        await query.edit_message_text("‚úÖ –¢–µ–º—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã! –¢–µ–ø–µ—Ä—å —Ç—ã –±—É–¥–µ—à—å –ø–æ–ª—É—á–∞—Ç—å —Ü–∏—Ç–∞—Ç—ã —Ç–æ–ª—å–∫–æ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–º —Ç–µ–º–∞–º.")
    
    elif data.startswith("toggle_"):
        theme_key = data.replace("toggle_", "")
        if theme_key in THEMES:
            stats = context.application.bot_data['user_stats'].setdefault(chat_id, {
                "count": 0,
                "selected_topics": list(THEMES.keys())
            })
            selected = stats.setdefault("selected_topics", list(THEMES.keys()))
            if theme_key in selected:
                selected.remove(theme_key)
            else:
                selected.append(theme_key)
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            await query.edit_message_reply_markup(reply_markup=get_topics_keyboard(selected))

# === –ó–∞–ø—É—Å–∫ ===
def main():
    global ALL_QUOTES
    ALL_QUOTES = load_quotes()

    application = Application.builder().token(BOT_TOKEN).build()
    load_state(application)

    def signal_handler(signum, frame):
        logger.info("–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ...")
        save_state(application)
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
        sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("stats", stats))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    application.add_handler(CallbackQueryHandler(button_handler))

    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    try:
        application.run_polling()
    except KeyboardInterrupt:
        logger.info("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ (Ctrl+C). –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ...")
        save_state(application)
        logger.info("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")

if __name__ == "__main__":
    main()
